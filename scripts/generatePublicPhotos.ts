import { mkdir, readdir, readFile, rm, stat, writeFile } from "node:fs/promises";
import path from "node:path";

import sharp from "sharp";

type GeneratedPhoto = {
  src: string;
  width: number;
  height: number;
  alt: string;
};

type CliOptions = {
  capBytes: number;
  maxDimensionPx: number;
  quality: number;
};

const DEFAULT_CAP_MB = 90;
const DEFAULT_MAX_DIMENSION_PX = 1600;
const DEFAULT_QUALITY = 82;

const SUPPORTED_EXTENSIONS = new Set([".avif", ".heic", ".heif", ".jpeg", ".jpg", ".png", ".webp"]);

function altFromFilename(filename: string): string {
  const base = filename.replace(/\.[^/.]+$/, "");
  return base.replace(/[-_]+/g, " ").trim() || "Photo";
}

function parseNumberFlag(args: readonly string[], flag: string): number | null {
  const idx = args.indexOf(flag);
  if (idx === -1) return null;
  const value = args[idx + 1];
  if (!value) return null;
  const parsed = Number(value);
  return Number.isFinite(parsed) ? parsed : null;
}

function parseOptions(argv: readonly string[]): CliOptions {
  const capMb = parseNumberFlag(argv, "--cap-mb") ?? DEFAULT_CAP_MB;
  const maxDimensionPx = parseNumberFlag(argv, "--max-dimension") ?? DEFAULT_MAX_DIMENSION_PX;
  const quality = parseNumberFlag(argv, "--quality") ?? DEFAULT_QUALITY;

  return {
    capBytes: Math.max(1, Math.floor(capMb * 1024 * 1024)),
    maxDimensionPx: Math.max(1, Math.floor(maxDimensionPx)),
    quality: Math.max(1, Math.min(100, Math.floor(quality))),
  };
}

async function listFilesRecursive(rootDir: string): Promise<string[]> {
  const result: string[] = [];

  async function walk(dir: string) {
    const entries = await readdir(dir, { withFileTypes: true });
    for (const entry of entries) {
      const abs = path.join(dir, entry.name);
      if (entry.isDirectory()) {
        await walk(abs);
        continue;
      }

      if (!entry.isFile()) continue;
      result.push(abs);
    }
  }

  await walk(rootDir);
  return result;
}

function formatBytes(bytes: number): string {
  if (bytes < 1024) return `${bytes} B`;
  const kb = bytes / 1024;
  if (kb < 1024) return `${kb.toFixed(1)} KB`;
  const mb = kb / 1024;
  return `${mb.toFixed(1)} MB`;
}

function toPosixPath(p: string): string {
  return p.split(path.sep).join("/");
}

function renderPhotosTs(photos: readonly GeneratedPhoto[]): string {
  const items = photos
    .map((photo) => {
      return [
        "  {",
        `    src: ${JSON.stringify(photo.src)},`,
        `    width: ${photo.width},`,
        `    height: ${photo.height},`,
        `    alt: ${JSON.stringify(photo.alt)},`,
        "  },",
      ].join("\n");
    })
    .join("\n");

  return [
    "/*",
    " * GENERATED FILE – DO NOT EDIT.",
    " *",
    " * Generated by: scripts/generatePublicPhotos.ts",
    " */",
    "",
    "export type PhotoItem = {",
    "  src: string;",
    "  width: number;",
    "  height: number;",
    "  alt: string;",
    "};",
    "",
    `export const PHOTOS: readonly PhotoItem[] = [`,
    items,
    "];",
    "",
  ].join("\n");
}

async function main(): Promise<void> {
  const options = parseOptions(process.argv.slice(2));

  const repoRoot = process.cwd();
  const imagesDir = path.join(repoRoot, "images");
  const outDir = path.join(repoRoot, "public", "photos");
  const dataFile = path.join(repoRoot, "src", "data", "photos.ts");

  // Ensure output directory exists and is clean.
  await rm(outDir, { recursive: true, force: true });
  await mkdir(outDir, { recursive: true });

  let allFiles: string[];
  try {
    allFiles = await listFilesRecursive(imagesDir);
  } catch {
    const empty = renderPhotosTs([]);
    await writeFile(dataFile, empty, "utf8");
    console.log(`No images directory found at ${imagesDir}; wrote empty list.`);
    return;
  }

  const candidates = allFiles
    .filter((absPath) => {
      const ext = path.extname(absPath).toLowerCase();
      return SUPPORTED_EXTENSIONS.has(ext);
    })
    .map((absPath) => ({ absPath, rel: path.relative(imagesDir, absPath) }));

  if (candidates.length === 0) {
    const empty = renderPhotosTs([]);
    await writeFile(dataFile, empty, "utf8");
    console.log(`No supported images found in ${imagesDir}; wrote empty list.`);
    return;
  }

  const withSizes = await Promise.all(
    candidates.map(async (file) => {
      const s = await stat(file.absPath);
      return { ...file, size: s.size };
    }),
  );

  // Greedy strategy for maximizing count: start with smallest inputs.
  withSizes.sort((a, b) => {
    if (a.size !== b.size) return a.size - b.size;
    return a.rel.localeCompare(b.rel, "en");
  });

  const photos: GeneratedPhoto[] = [];
  let bytesWritten = 0;

  for (const file of withSizes) {
    const ext = path.extname(file.absPath).toLowerCase();
    const relPosix = toPosixPath(file.rel);
    const alt = altFromFilename(path.basename(file.absPath));

    let outputBuffer: Buffer;
    let outputWidth = DEFAULT_MAX_DIMENSION_PX;
    let outputHeight = DEFAULT_MAX_DIMENSION_PX;

    try {
      const isHeic = ext === ".heic" || ext === ".heif";

      try {
        const pipeline = sharp(file.absPath, { failOn: "none", sequentialRead: true })
          .rotate()
          .resize(options.maxDimensionPx, options.maxDimensionPx, {
            fit: "inside",
            withoutEnlargement: true,
          })
          .webp({ quality: options.quality });

        const { data, info } = await pipeline.toBuffer({ resolveWithObject: true });
        outputBuffer = data;
        outputWidth = info.width ?? outputWidth;
        outputHeight = info.height ?? outputHeight;
      } catch (error) {
        // If Sharp doesn't support HEIC/HEIF on this platform, fall back to WASM conversion.
        if (!isHeic) throw error;

        const { default: heicConvert } = await import("heic-convert");
        const input = await readFile(file.absPath);
        const jpeg = await heicConvert({ buffer: input, format: "JPEG", quality: 0.92 });

        const pipeline = sharp(jpeg)
          .rotate()
          .resize(options.maxDimensionPx, options.maxDimensionPx, {
            fit: "inside",
            withoutEnlargement: true,
          })
          .webp({ quality: options.quality });

        const { data, info } = await pipeline.toBuffer({ resolveWithObject: true });
        outputBuffer = data;
        outputWidth = info.width ?? outputWidth;
        outputHeight = info.height ?? outputHeight;
      }
    } catch (error) {
      console.warn(`Skipping ${relPosix} (${ext}) – conversion failed.`);
      if (error instanceof Error) console.warn(error.message);
      continue;
    }

    if (bytesWritten > 0 && bytesWritten + outputBuffer.byteLength > options.capBytes) {
      break;
    }

    const index = photos.length + 1;
    const filename = `photo-${String(index).padStart(4, "0")}.webp`;
    const outPath = path.join(outDir, filename);
    await writeFile(outPath, outputBuffer);

    bytesWritten += outputBuffer.byteLength;

    photos.push({
      src: `/photos/${filename}`,
      width: outputWidth,
      height: outputHeight,
      alt,
    });
  }

  await mkdir(path.dirname(dataFile), { recursive: true });
  await writeFile(dataFile, renderPhotosTs(photos), "utf8");

  console.log(
    `Generated ${photos.length} photos into public/photos (total ${formatBytes(bytesWritten)} / cap ${formatBytes(options.capBytes)}).`,
  );
}

await main();
